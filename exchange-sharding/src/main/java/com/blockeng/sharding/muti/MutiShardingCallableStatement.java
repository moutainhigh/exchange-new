package com.blockeng.sharding.muti;


import com.blockeng.sharding.muti.adapter.CallableStatementAdapter;
import lombok.Getter;

import java.sql.*;

@Getter
public class MutiShardingCallableStatement extends CallableStatementAdapter implements CallableStatement {


    private Connection trueConnection;

    private volatile CallableStatement trueStatement;

    private String sql;

    @Deprecated
    private MutiShardingCallableStatement(MutiShardingConnection mutiShardingConnection) {
        super(mutiShardingConnection);
    }


    private CallableStatement getTrueStatement0() {
        return (CallableStatement) getTrueStatement();
    }

    public MutiShardingCallableStatement(MutiShardingConnection mutiShardingConnection, String sql) {
        super(mutiShardingConnection);
        this.sql = sql;
        try {
            cachedStatementsAndGet(sql);
        } catch (SQLException e) {
            e.printStackTrace();
        }

    }

    public MutiShardingCallableStatement(MutiShardingConnection mutiShardingConnection, String sql,
                                         int resultType, int resultSetConcurrency) {
        super(mutiShardingConnection, resultType, resultSetConcurrency);
        this.sql = sql;
        try {
            cachedStatementsAndGet(sql);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public MutiShardingCallableStatement(MutiShardingConnection mutiShardingConnection, String sql,
                                         int resultType, int resultSetConcurrency, int resultSetHoldability) {
        super(mutiShardingConnection, resultType, resultSetConcurrency, resultSetHoldability);
        this.sql = sql;
        try {
            cachedStatementsAndGet(sql);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }


    @Override
    protected Statement cachedStatementsAndGet(String sql) throws SQLException {
        if (isClosed()) throw new RuntimeException("statement is closed");
        String tableName = ((tableName = getParser().parserTableName(sql)) != null) ? tableName :
                getMutiShardingConnection().getDataSource().getDataSourceMap().keySet().iterator().next();
        if (!this.getCachedStatements().containsKey(tableName)) {
            Connection connection = cachedConnectionAndGet(getMutiShardingConnection(), tableName);
            CallableStatement statement = connection.prepareCall(sql, getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());
            if (null == trueConnection)
                trueConnection = connection;
            if (null == trueStatement)
                trueStatement = statement;
            getCachedStatements().put(tableName, statement);
        }
        return getCachedStatements().get(tableName);
    }


    @Override
    public ResultSet executeQuery() throws SQLException {
        return getTrueStatement0().executeQuery();
    }

    @Override
    public int executeUpdate() throws SQLException {
        return getTrueStatement0().executeUpdate();
    }


    @Override
    public void clearParameters() throws SQLException {
        getTrueStatement0().clearParameters();
    }


    @Override
    public boolean execute() throws SQLException {
        return getTrueStatement0().execute();
    }

    @Override
    public void addBatch() throws SQLException {
        getTrueStatement0().addBatch();
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        getTrueStatement0().addBatch(sql);
    }

    @Override
    public void clearBatch() throws SQLException {
        getTrueStatement0().clearBatch();
    }

    @Override
    public int[] executeBatch() throws SQLException {
        return getTrueStatement0().executeBatch();
    }


    @Override
    public long[] executeLargeBatch() throws SQLException {
        return getTrueStatement0().executeLargeBatch();
    }

    @Override
    public long executeLargeUpdate(String sql) throws SQLException {
        return getTrueStatement0().executeLargeUpdate(sql);
    }

    @Override
    public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return getTrueStatement0().executeLargeUpdate(sql, autoGeneratedKeys);
    }

    @Override
    public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return getTrueStatement0().executeLargeUpdate(sql, columnIndexes);
    }

    @Override
    public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {
        return getTrueStatement0().executeLargeUpdate(sql, columnNames);
    }


    @Override
    public ResultSetMetaData getMetaData() throws SQLException {
        return getTrueStatement0().getMetaData();
    }


    @Override
    public long executeLargeUpdate() throws SQLException {
        return getTrueStatement0().executeLargeUpdate();
    }


}
