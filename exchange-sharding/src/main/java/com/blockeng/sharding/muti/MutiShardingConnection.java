package com.blockeng.sharding.muti;

import com.blockeng.sharding.muti.adapter.ConnectionAdapter;
import lombok.Getter;
import lombok.Setter;
import org.springframework.util.Assert;

import java.sql.*;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

@Getter
@Setter
public class MutiShardingConnection extends ConnectionAdapter {

    private MutiShardingDataSource dataSource;

    private Map<String, Connection> cachedConnections;

    private MutiShardingNativeStatement nativeStatement;

    private volatile Connection trueConnection;

    private volatile String trueConnectionTableName;

    private String username;
    private String password;
    private int timeout = 0;
    private boolean hasPassword;
    private volatile boolean autoCommit = true;

    public MutiShardingConnection(MutiShardingDataSource mutiShardingDataSource) {
        this(mutiShardingDataSource, null, null, 0);
        this.hasPassword = false;
    }

    @Override
    public void setAutoCommit(boolean autoCommit) throws SQLException {
        this.autoCommit = autoCommit;
        super.setAutoCommit(autoCommit);
    }

    @Override
    public boolean getAutoCommit() {
        return this.autoCommit;
    }

    public MutiShardingConnection(MutiShardingDataSource mutiShardingDataSource, String username, String password, int timeout) {
        this.username = username;
        this.password = password;
        this.timeout = timeout;
        this.dataSource = mutiShardingDataSource;
        this.cachedConnections = new ConcurrentHashMap<>();
        this.nativeStatement = new MutiShardingNativeStatement(this);
        this.hasPassword = true;
    }

    @Override
    public Statement createStatement() throws SQLException {
        MutiShardingStatement statement = new MutiShardingStatement(this);
        //  cachedMutiStatements.add(statement);
        return statement;
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        MutiShardingStatement statement = new MutiShardingStatement(this, resultSetType, resultSetConcurrency);
        //   cachedMutiStatements.add(statement);
        return statement;
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        MutiShardingStatement statement = new MutiShardingStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability);
        //   cachedMutiStatements.add(statement);
        return statement;
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        MutiShardingPrepareStatement statement = new MutiShardingPrepareStatement(this, sql);
        //   cachedMutiPrepareStatements.add(statement);
        return statement;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        MutiShardingPrepareStatement statement = new MutiShardingPrepareStatement(this, sql, resultSetType, resultSetConcurrency);
        //   cachedMutiPrepareStatements.add(statement);
        return statement;
    }


    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {

        MutiShardingPrepareStatement statement = new MutiShardingPrepareStatement(this, sql, autoGeneratedKeys);
        //    cachedMutiPrepareStatements.add(statement);
        return statement;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        MutiShardingPrepareStatement statement = new MutiShardingPrepareStatement(this, sql, columnIndexes);
        //   cachedMutiPrepareStatements.add(statement);
        return statement;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        MutiShardingPrepareStatement statement = new MutiShardingPrepareStatement(this, sql, columnNames);
        //   cachedMutiPrepareStatements.add(statement);
        return statement;
    }


    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        MutiShardingPrepareStatement statement = new MutiShardingPrepareStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
        // cachedMutiPrepareStatements.add(statement);
        return statement;
    }


    @Override
    public CallableStatement prepareCall(String sql) throws SQLException {
        MutiShardingCallableStatement statement = new MutiShardingCallableStatement(this, sql);
        //  cachedMutiCallableStatements.add(statement);
        return statement;
    }

    @Override
    public String nativeSQL(String sql) throws SQLException {
        return nativeStatement.nativeSQL(sql);
    }


    public DatabaseMetaData getMetaData(String tableName) throws SQLException {
        Assert.isTrue(dataSource.getDataSourceMap().containsKey(tableName), String.format("Miss table %s", tableName));
        Connection connection = dataSource.getDataSourceMap().get(tableName).getConnection();
        try {
            return connection.getMetaData();
        } finally {
            connection.close();
        }
    }

    @Override
    protected Connection getAnyTrueConnnection() throws SQLException {
        return trueConnection == null ? dataSource.getDataSourceMap()
                .entrySet()
                .iterator()
                .next()
                .getValue()
                .getConnection() : trueConnection;
    }

    @Override
    protected Connection getAnyMateConnection() throws SQLException {
        return trueConnection == null ? dataSource.getDataSourceMap()
                .entrySet()
                .iterator()
                .next()
                .getValue()
                .getConnection():dataSource.getDataSourceMap().get(trueConnectionTableName).getConnection();
    }

    @Override
    protected void eachConnections(Consumer<Connection> consumer) {
        cachedConnections.values().forEach(consumer::accept);
    }



    @Override
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return prepareCall(sql, resultSetType, resultSetConcurrency);
    }

    @Override
    public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }


}
